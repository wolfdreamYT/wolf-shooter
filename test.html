<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf Shooter - Beta 1.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid black;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, green, yellow, red);
            transition: width 0.5s;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>
    <script>
        let scene, camera, renderer;
        let controls = { forward: false, backward: false, left: false, right: false, jump: false };
        let bullets = [];
        let velocity = new THREE.Vector3();
        let gravity = -0.01;
        let isGrounded = false;
        let enemy, enemyBullets = [], enemyCooldown = 3000, lastShot = 0, enemyAlive = true;
        let spawnPoint = new THREE.Vector3(0, 2, 0);
        let playerHealth = 100;
        const obstacles = [];
        const lookSpeed = 0.002;

        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = playerHealth + '%';
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            document.body.addEventListener('click', () => document.body.requestPointerLock());

            // Floor
            const floorTexture = new THREE.TextureLoader().load('floor.jpg');
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ map: floorTexture }));
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            
            // Walls
            const wallTexture = new THREE.TextureLoader().load('wall.jpg');
            for (let i = 0; i < 4; i++) {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(50, 10, 1), new THREE.MeshBasicMaterial({ map: wallTexture }));
                if (i % 2 === 0) {
                    wall.rotation.y = Math.PI / 2;
                }
                wall.position.set(i < 2 ? -25 + i * 50 : 0, 5, i < 2 ? 0 : -25 + (i - 2) * 50);
                scene.add(wall);
                obstacles.push(wall);
            }

            // Obstacles
            const textures = [
                new THREE.TextureLoader().load('obstacle.jpg'),
                new THREE.TextureLoader().load('obstacle1.jpg'),
                new THREE.TextureLoader().load('obstacle2.jpg'),
                new THREE.TextureLoader().load('obstacle3.jpg')
            ];

            for (let i = 0; i < 30; i++) {
                const randomTexture = textures[Math.floor(Math.random() * textures.length)]; // Pick a random texture

                const box = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.MeshBasicMaterial({ map: randomTexture })
                );

                box.position.set(Math.random() * 60 - 20, 1, Math.random() * 50 - 20);
                scene.add(box);
                obstacles.push(box);
            }
            
            // Enemy
            const enemyTexture = new THREE.TextureLoader().load('enemy.jpg');
            enemy = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ map: enemyTexture }));
            enemy.position.set(10, 1, 10);
            scene.add(enemy);
            
            camera.position.copy(spawnPoint);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', shoot);
            document.addEventListener('mousemove', lookAround);
            updateHealthBar();
            animate();
        }

        function onKeyDown(event) {
            if (event.key === 'w') controls.forward = true;
            if (event.key === 's') controls.backward = true;
            if (event.key === 'd') controls.left = true;
            if (event.key === 'a') controls.right = true;
            if (event.key === ' ') controls.jump = true;
        }

        function onKeyUp(event) {
            if (event.key === 'w') controls.forward = false;
            if (event.key === 's') controls.backward = false;
            if (event.key === 'd') controls.left = false;
            if (event.key === 'a') controls.right = false;
            if (event.key === ' ') controls.jump = false;
        }

        function lookAround(event) {
            if (document.pointerLockElement === document.body) {
                const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                euler.setFromQuaternion(camera.quaternion);

                euler.y -= event.movementX * lookSpeed; 
                euler.x -= event.movementY * lookSpeed;

                euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }
        }

        function shoot() {
            const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            bullet.position.copy(camera.position);
            bullet.velocity = new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3())).multiplyScalar(0.5);
            bullets.push(bullet);
            scene.add(bullet);
        }

        function enemyShoot() {
            if (enemyAlive && Date.now() - lastShot > enemyCooldown) {
                const enemyBullet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                enemyBullet.position.copy(enemy.position);
                enemyBullet.velocity = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize().multiplyScalar(0.5);
                enemyBullets.push(enemyBullet);
                scene.add(enemyBullet);
                lastShot = Date.now();
            }
        }

        function checkCollisions(object, obstacles) {
            for (const obstacle of obstacles) {
                const distance = object.position.distanceTo(obstacle.position);
                if (distance < 2) return true;
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);

            let direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const nextPosition = camera.position.clone();
            if (controls.forward) nextPosition.add(direction.clone().multiplyScalar(0.1));
            if (controls.backward) nextPosition.add(direction.clone().multiplyScalar(-0.1));
            if (controls.left) nextPosition.add(new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), direction).multiplyScalar(-0.1));
            if (controls.right) nextPosition.add(new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), direction).multiplyScalar(0.1));

            if (!checkCollisions({ position: nextPosition }, obstacles)) {
                camera.position.copy(nextPosition);
            }

            if (controls.jump && isGrounded) velocity.y = 0.2;
            velocity.y += gravity;
            camera.position.y += velocity.y;
            if (camera.position.y <= 2) { camera.position.y = 2; isGrounded = true; velocity.y = 0; }
            else { isGrounded = false; }

            bullets.forEach((bullet, index) => {
                bullet.position.add(bullet.velocity);

                if (checkCollisions(bullet, obstacles) || bullet.position.distanceTo(enemy.position) < 1) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);

                    if (bullet.position.distanceTo(enemy.position) < 1 && enemyAlive) {
                        enemyAlive = false;
                        scene.remove(enemy);
                        setTimeout(() => {
                            enemyAlive = true;
                            enemy.position.set(10, 1, 10);
                            scene.add(enemy);
                        }, 5000);
                    }
                }
            });

            enemyBullets.forEach((bullet, index) => {
                bullet.position.add(bullet.velocity);
                if (bullet.position.distanceTo(camera.position) < 1) {
                    playerHealth -= 70;
                    updateHealthBar();
                    scene.remove(bullet);
                    enemyBullets.splice(index, 1);
                    if (playerHealth <= 0) {
                        alert("You died! Respawning...")
                        camera.position.copy(spawnPoint); 
                        playerHealth = 100; 
                        updateHealthBar();
                    }
                } else if (checkCollisions(bullet, obstacles) || bullet.position.length() > 50) {
                    scene.remove(bullet);
                    enemyBullets.splice(index, 1);
                }
            });

            enemyShoot();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();

        console.log("enemyAlive:", enemyAlive);
    </script>
</body>
</html>
