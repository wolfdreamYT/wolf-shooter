<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf Shooter - Beta 3.1</title>
    <link rel="icon" href="favicon.ico?v=1" type="image/x-icon">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background-color: brown;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #health-bar {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(255, 0, 0, 0.5);
            border: 2px solid black;
        }
        #health-fill {
            width: 100%;
            max-width: 200px;
            height: 100%;
            background: linear-gradient(90deg, green, yellow, red);
            transition: width 0.5s;
        }
        .gun {
            position: absolute;
            left: 41%;
            bottom: -170px;
            transform: translateX(-50%);
            width: 40vw;
            height: auto; 
            max-width: 1000px;
            max-height: 1000px; 
            scale: 60%;
        }
        .shop-button {
            width: 200px;
            height: 60px;
            background-color: rgb(92, 143, 231);
            border: solid;
            border-color: rgb(11, 22, 120);
            border-radius: 8px;
            border-width: 1px;
        }
        .shop-button-close {
            width: 100px;
            height: 60px;
            background-color: rgb(92, 143, 231);
            border: solid;
            border-color: rgb(11, 22, 120);
            border-radius: 8px;
            border-width: 1px;
        }
        .menu-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-align: center;
            width: 300px;
            z-index: 10;
            display: none; 
        }

        .menu-button {
            width: 200px;
            height: 50px;
            background-color: rgb(92, 143, 231);
            border: solid 1px rgb(11, 22, 120);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: 0.2s;
        }
        .menu-button1 {
            width: 200px;
            height: 50px;
            background-color: rgb(92, 143, 231);
            border: solid 1px rgb(11, 22, 120);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: 0.2s;
        }
        .menu-button2 {
            width: 200px;
            height: 50px;
            background-color: rgb(92, 143, 231);
            border: solid 1px rgb(11, 22, 120);
            border-radius: 8px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: 0.2s;
        }

        .menu-button:hover {
            background-color: rgb(50, 100, 200);
        }

        #mobile-controls {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #joystick-container {
            position: absolute;
            bottom: 15%;
            left: 10%;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        #joystick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .mobile-btn {
            position: absolute;
            width: 80px;
            height: 80px;
            font-size: 24px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 2px solid black;
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        #btn-shoot {
            bottom: 15%;
            right: 10%;
        }

        #btn-jump {
            bottom: 30%;
            right: 10%;
        }

    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>

    <div id="ammo-display" style="
        position: absolute; top: 50px; left: 20px; 
        font-size: 20px; color: white; background: rgba(0, 0, 0, 0.5);
        padding: 5px; border-radius: 5px;">
        Ammo: 3
    </div>
    <div id="score-display" style="
        position: absolute; top: 80px; left: 20px; 
        font-size: 20px; color: white; background: rgba(0, 0, 0, 0.5);
        padding: 5px; border-radius: 5px;">
        Score: 0
    </div>

    <div id="magazine-display" style="
        position: absolute; top: 110px; left: 20px; 
        font-size: 20px; color: white; background: rgba(0, 0, 0, 0.5);
        padding: 5px; border-radius: 5px;">
        Mag: 15 / 15
    </div>

    <div id="shop-menu" style="
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 20px;
        border-radius: 10px;
        color: white;
        display: none;
        width: 300px;
        text-align: center;
        z-index: 20; /* Ensures it's on top */
    ">
        <h2>Shop</h2>
        <button class="shop-button" onclick="buyItem('ammo')">Ammo (+5) - 100 Points</button><br><br>
        <button class="shop-button" onclick="buyItem('health')">Health (+50) - 150 Points</button><br><br>
        <button class="shop-button-close" onclick="closeShop()">Close</button>
    </div>

    <button id="login-button" style="
        position: absolute; top: 10px; right: 10px;
        background: #444; color: white; padding: 10px 15px;
        border: none; border-radius: 5px; cursor: pointer;">
        Login
    </button>

    <div id="battlepass-ui" style="
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 20px;
        border-radius: 10px;
        color: white;
        display: none;
        width: 300px;
        text-align: center;
        z-index: 9999;">
        <h2>Battle Pass</h2>
        <p>Level: <span id="bp-level">1</span></p>
        <p>Progress: <span id="bp-progress">0</span> / 1000</p>
        <div style="width: 100%; height: 20px; background: gray; border-radius: 5px; overflow: hidden;">
            <div id="bp-progress-bar" style="width: 0%; height: 100%; background: gold;"></div>
        </div>
        <button onclick="closeBattlePass()" style="
            margin-top: 10px;
            background: red; color: white; padding: 5px 10px;
            border: none; border-radius: 5px; cursor: pointer;">
            Close
        </button>
    </div>

    <div id="startup-menu" style="
        position: absolute; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8); 
        padding: 20px; 
        border-radius: 10px; 
        color: white; 
        text-align: center; 
        width: 300px;
        z-index: 9999;">
        <h2>Welcome to Wolf Shooter</h2>
        <button class="menu-button" onclick="startGame()">Play</button><br><br>
        <button class="menu-button1" onclick="toggleShop()">Shop</button>
        <button class="menu-button2" onclick="toggleBattlePass()">Battle Pass</button>
    </div>

    <div id="mobile-controls" style="display: none;">
        <div id="joystick-container">
            <div id="joystick"></div>
        </div>

        <button class="mobile-btn" id="btn-shoot">üî´</button>
        <button class="mobile-btn" id="btn-jump">‚è´</button>
    </div>

    <audio id="main-music">
        <source src="music1.mp3" type="audio/mpeg">
    </audio>

    <script>
        function isMobileDevice() {
            return /Mobi|Android|iPhone|iPad|iPod/.test(navigator.userAgent);
        }

        if (isMobileDevice()) {
            document.getElementById("mobile-controls").style.display = "block";
        }

        let joystick = document.getElementById("joystick");
        let joystickContainer = document.getElementById("joystick-container");
        let touchControls = { forward: false, backward: false, left: false, right: false };

        joystickContainer.addEventListener("touchstart", (event) => {
            let startX = event.touches[0].clientX;
            let startY = event.touches[0].clientY;

            function moveJoystick(e) {
                let deltaX = e.touches[0].clientX - startX;
                let deltaY = e.touches[0].clientY - startY;

                joystick.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

                touchControls.forward = deltaY < -30;
                touchControls.backward = deltaY > 30;
                touchControls.left = deltaX < -30;
                touchControls.right = deltaX > 30;
            }

            function endJoystick() {
                joystick.style.transform = `translate(-50%, -50%)`;
                touchControls = { forward: false, backward: false, left: false, right: false };
                document.removeEventListener("touchmove", moveJoystick);
                document.removeEventListener("touchend", endJoystick);
            }

            document.addEventListener("touchmove", moveJoystick);
            document.addEventListener("touchend", endJoystick);
        });

        document.getElementById("btn-shoot").addEventListener("touchstart", () => {
            shoot(); 
        });

        document.getElementById("btn-jump").addEventListener("touchstart", () => {
            touchControls.jump = true;
            setTimeout(() => touchControls.jump = false, 200);
        });

        let lastTouchX, lastTouchY;
        document.addEventListener("touchstart", (event) => {
            lastTouchX = event.touches[0].clientX;
            lastTouchY = event.touches[0].clientY;
        }, false);

        document.addEventListener("touchmove", (event) => {
            if (event.touches.length === 1 && event.touches[0].clientX > window.innerWidth / 2) {
                let deltaX = event.touches[0].clientX - lastTouchX;
                let deltaY = event.touches[0].clientY - lastTouchY;
                lastTouchX = event.touches[0].clientX;
                lastTouchY = event.touches[0].clientY;

                const sensitivity = 0.005; 
                const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                euler.setFromQuaternion(camera.quaternion);

                euler.y -= deltaX * sensitivity;
                euler.x -= deltaY * sensitivity;
                euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));

                camera.quaternion.setFromEuler(euler);
            }
        }, false);

        function updateMobileMovement() {
            let moveSpeed = 0.2; 

            let direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (touchControls.forward) camera.position.add(direction.clone().multiplyScalar(moveSpeed));
            if (touchControls.backward) camera.position.add(direction.clone().multiplyScalar(-moveSpeed));
            if (touchControls.left) camera.position.add(new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), direction).multiplyScalar(-moveSpeed));
            if (touchControls.right) camera.position.add(new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), direction).multiplyScalar(moveSpeed));

            if (touchControls.jump) camera.position.y += 0.3;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMobileMovement();
            renderer.render(scene, camera);
        }

    </script>
      
    <script>
        document.addEventListener("DOMContentLoaded", function() {
          let audio = document.getElementById("main-music");
          audio.loop = true;
          audio.play().catch(error => console.log("Autoplay prevented, user interaction required."));
        });
    </script>     
    <script>
        function respawnPlayer() {
            playerHealth = 200; 
            camera.position.copy(spawnPoint); 
            velocity.set(0, 0, 0); 
            updateHealthBar();
            console.log("Player has respawned at spawn point.");
        }
    </script>

    <img class="gun" src="gun1.png">
    <audio id="jump-sound" src="jumping.mp3"></audio>
    <audio id="walking-sound" src="walk.mp3" loop></audio>
    <audio id="reload-sound" src="reload.mp3"></audio>
    <audio id="shop-click-sound" src="click.mp3"></audio>
    <audio id="purchase-success-sound" src="success.mp3"></audio>
    <audio id="error-sound" src="error.mp3"></audio>
    <audio id="cocking-sound" src="gun-cocking.mp3"></audio>
    <audio id="gunshot-sound" src="gunshot.mp3"></audio>
    <script>
        function startGame() {
            document.getElementById("startup-menu").style.display = "none";
            isPaused = false;
            isGameStarted = true;
            lockCursor();
        }

        document.addEventListener("keydown", function(event) {
            if (event.key === "Escape") {
                togglePause();
            }
        });

        function togglePause() {
            if (isPaused) {
                document.getElementById("startup-menu").style.display = "none";
                isPaused = false;
                lockCursor();
            } else {
                document.getElementById("startup-menu").style.display = "block";
                isPaused = true;
                unlockCursor();
            }
        }
    </script>
    <script>
        function hideAllUI() {
            document.getElementById("startup-menu").style.display = "none";
            document.getElementById("shop-menu").style.display = "none";
            document.getElementById("battlepass-ui").style.display = "none";
        }

        function toggleShop() {
            let shopMenu = document.getElementById('shop-menu');

            if (shopMenu.style.display === "block") {
                shopMenu.style.display = "none";
                lockCursor();
                enableControls();
            } else {
                hideAllUI(); 
                shopMenu.style.display = "block";
                unlockCursor();
                disableControls();
            }
        }

        function toggleBattlePass() {
            let battlePassMenu = document.getElementById('battlepass-ui');

            if (battlePassMenu.style.display === "block") {
                battlePassMenu.style.display = "none";
                lockCursor();
                enableControls();
            } else {
                hideAllUI(); 
                battlePassMenu.style.display = "block";
                unlockCursor();
                disableControls();
            }
        }

        function startGame() {
            hideAllUI();
            lockCursor();
        }
    </script>

    <script>
        let battlePassOpen = false;
        let bpLevel = 1;
        let bpProgress = 0;
        const bpRequiredPoints = 1000; 
        const bpRewards = {
            1: { ammo: 0, score: 0 },
            2: { ammo: 25, score: 100 },
            3: { ammo: 50, score: 0 },
            4: { ammo: 25, score: 250 },
            5: { ammo: 65, score: 0 },
            6: { ammo: 25, score: 400 },
            7: { ammo: 80, score: 0 },
            8: { ammo: 25, score: 650 },
            9: { ammo: 100, score: 0 },
            10: { ammo: 25, score: 800 },
            11: { ammo: 120, score: 0 },
            12: { ammo: 25, score: 950 },
            13: { ammo: 140, score: 0 },
            14: { ammo: 25, score: 1000 },
            15: { ammo: 160, score: 0 },
            16: { ammo: 25, score: 1150 },
            17: { ammo: 180, score: 0 },
            18: { ammo: 25, score: 1200 },
            19: { ammo: 200, score: 0 },
            20: { ammo: 25, score: 1350 },
            21: { ammo: 215, score: 0 },
            22: { ammo: 25, score: 1400 },
            23: { ammo: 230, score: 0 },
            24: { ammo: 25, score: 1500 },
            25: { ammo: 250, score: 0 },
            26: { ammo: 25, score: 1650 },
            27: { ammo: 265, score: 0 },
            28: { ammo: 25, score: 1850 },
            29: { ammo: 280, score: 0 },
            30: { ammo: 25, score: 2000 },
            31: { ammo: 295, score: 0 },
            32: { ammo: 25, score: 2050 },
            33: { ammo: 300, score: 0 },
            34: { ammo: 25, score: 2150 },
            35: { ammo: 315, score: 0 },
            36: { ammo: 25, score: 2300 },
            37: { ammo: 340, score: 0 },
            38: { ammo: 25, score: 2450 },
            39: { ammo: 365, score: 0 },
            40: { ammo: 25, score: 2650 },
            41: { ammo: 380, score: 0 },
            42: { ammo: 25, score: 2800 },
            43: { ammo: 400, score: 0 },
            44: { ammo: 25, score: 3000 },
            45: { ammo: 420, score: 0 },
            46: { ammo: 25, score: 3200 },
            47: { ammo: 435, score: 0 },
            48: { ammo: 25, score: 3400 },
            49: { ammo: 450, score: 0 },
            50: { ammo: 25, score: 3500 },
        };

        document.addEventListener('keydown', function (event) {
            if (event.key === "p" || event.key === "P") {
                toggleBattlePass();
            }
        });

        function toggleBattlePass() {
            let battlePassMenu = document.getElementById('battlepass-ui');

            if (battlePassMenu.style.display === "block") {
                battlePassMenu.style.display = "none";
                lockCursor();
                enableControls();
            } else {
                hideAllUI(); 
                battlePassMenu.style.display = "block";
                unlockCursor();
                disableControls();
            }
        }

        function closeBattlePass() {
            document.getElementById('battlepass-ui').style.display = "none";
            lockCursor();
            battlePassOpen = false;
            enableControls();
        }

        function addBattlePassProgress(pointsEarned) {
            bpProgress += pointsEarned;

            updateBattlePassUI();

            while (bpProgress >= bpRequiredPoints) {
                if (bpLevel < 50) {
                    levelUpBattlePass();
                } else {
                    bpProgress -= bpRequiredPoints;
                    ammo += 10;
                    playSound("purchase-success-sound");
                    updateAmmoDisplay();
                    console.log(`üéâ Max Level! Received +10 Ammo`);
                }
                updateBattlePassUI();
            }
        }

        function levelUpBattlePass() {
            if (bpLevel < 50) {
                bpProgress -= bpRequiredPoints;
                bpLevel++;

                let reward = bpRewards[bpLevel];
                ammo += reward.ammo;
                score += reward.score;
                playSound("purchase-success-sound");

                updateAmmoDisplay();
                updateScoreDisplay();
                console.log(`üéâ Leveled up to ${bpLevel}! Rewards: Ammo +${reward.ammo}, Score +${reward.score}`);
            }
        }

        function updateBattlePassUI() {
            document.getElementById('bp-level').innerText = bpLevel;
            document.getElementById('bp-progress').innerText = bpProgress;
            
            let progressPercentage = (bpProgress / bpRequiredPoints) * 100;
            document.getElementById('bp-progress-bar').style.width = progressPercentage + "%";
        }
    </script>
    <script>
        let isAdmin = false;
        let isFlying = false;

        document.getElementById("login-button").addEventListener("click", function () {
            let password = prompt("Enter Admin Password, Hint: its only numbers, think about captain amarica 2");
            if (password === "8539") { 
                isAdmin = true;
                alert("Admin Access Granted!");
                ammo = 9999999999999;
                score = 9999999999999;
                updateAmmoDisplay();
            } else {
                alert("Incorrect Password!");
            }
        });

        document.addEventListener("keydown", function (event) {
            if (isAdmin && event.key === "f") {
                isFlying = !isFlying;
                if (isFlying) {
                    velocity.y = 0;
                }
            }
        });

        function applyFlightMode() {
            if (isAdmin && isFlying) {
                velocity.y = 0;

                if (controls.jump) camera.position.y += 0.2; 
                if (controls.backward) camera.position.y -= 0.2; 
                if (controls.sneak) camera.position.y -= 0.2; 
            } else {
                velocity.y += gravity; 
            }
        }
    </script>
    <script>
        let isShopOpen = false; 

        function toggleShop() {
            let shopMenu = document.getElementById('shop-menu');

            if (shopMenu.style.display === "block") {
                shopMenu.style.display = "none";
                lockCursor();
                enableControls();
            } else {
                hideAllUI(); 
                shopMenu.style.display = "block";
                unlockCursor();
                disableControls();
            }
        }

        function unlockCursor() {
            document.exitPointerLock();
        }

        function lockCursor() {
            if (!isShopOpen) {
                document.body.requestPointerLock();
            }
        }

        function disableControls() {
            document.removeEventListener('mousemove', lookAround);
            document.removeEventListener('mousedown', shoot);
        }

        function enableControls() {
            document.addEventListener('mousemove', lookAround);
            document.addEventListener('mousedown', shoot);
        }

        function playSound(soundId) {
            let sound = document.getElementById(soundId);
            if (sound) {
                sound.currentTime = 0; 
                sound.play();
            }
        }

        function buyItem(item) {
            if (item === "ammo" && score >= 100) {
                score -= 100;
                ammo += 5;
                updateAmmoDisplay();
                updateScoreDisplay();
                playSound("purchase-success-sound");
            } else if (item === "health" && score >= 150) {
                score -= 150;
                playerHealth += 50;
                updateHealthBar();
                updateScoreDisplay();
                playSound("purchase-success-sound");
            } else {
                playSound("error-sound");
            }
        }

        function closeShop() {
            playSound("shop-click-sound");
            document.getElementById('shop-menu').style.display = "none";
            lockCursor();
            isShopOpen = false;
            enableControls();
        }

        document.addEventListener('keydown', function(event) {
            if (event.key === 'b' || event.key === 'B') {
                toggleShop();
            }
        });
    </script>
    
    <script>
        let scene, camera, renderer;
        let controls = { forward: false, backward: false, left: false, right: false, jump: false };
        let bullets = [];
        let velocity = new THREE.Vector3();
        let gravity = -0.005;
        let isGrounded = false;

        let isPaused = true; 
        let isGameStarted = false; 

        let walkSpeed = 0.20; 
        let sprintSpeed = 0.30; 
        let isSprinting = false;
        let sprintTime = 0; 
        let sprintCooldown = false;

        let enemies = [];
        let enemyBullets = [];
        let enemyCooldown = 10000, lastShot = 0;
        let spawnPoint = new THREE.Vector3(0, 2, 0);
        let playerHealth = 200;
        let enemySpeed = 0.03; 
        let detectionRange = 50; 
        let stopRange = 2;
        let ammo = 15;
        let enemyAlive = enemies.length > 0;
        let score = 0;
        let magazineSize = 15; 
        let bulletsInMag = 15;  
        let isReloading = false;

        let walkingSound = document.getElementById("walking-sound");
        let jumpSound = document.getElementById("jump-sound");
        let isMoving = false;
        let isJumping = false;
        let playerBulletSpeed = 1.0; 
        let enemyBulletSpeed = 0.5; 


        const obstacles = [];
        const lookSpeed = 0.002;

        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = playerHealth + '%';
        }

        function updateAmmoDisplay() {
            document.getElementById('ammo-display').innerText = "Ammo: " + ammo;
        }

        function updateScoreDisplay() {
            document.getElementById('score-display').innerText = "Score: " + score;
        }
        document.addEventListener("keydown", function(event) {
            if (event.key === "r" || event.key === "R") {
                startReload();
            }
        });

        const chunkSize = 32;
        const loadedChunks = new Map();

        function getChunkKey(x, z) {
            return `${Math.floor(x / chunkSize)},${Math.floor(z / chunkSize)}`;
        }

        function generateChunk(x, z) {
            const key = getChunkKey(x, z);
            if (loadedChunks.has(key)) return; 

            const chunkObjects = [];

            const floorTexture = new THREE.TextureLoader().load('floor.jpg');
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(chunkSize, chunkSize),
                new THREE.MeshBasicMaterial({ map: floorTexture })
            );
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(x + chunkSize / 2, 0, z + chunkSize / 2);
            scene.add(floor);
            chunkObjects.push(floor);

            if (Math.random() < 1 / 1) {
                const enemyTexture = new THREE.TextureLoader().load('enemy.jpg');
                const enemy = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 2, 1),
                    new THREE.MeshBasicMaterial({ map: enemyTexture })
                );
                enemy.position.set(x + Math.random() * chunkSize, 1, z + Math.random() * chunkSize);
                scene.add(enemy);
                enemies.push(enemy);
                chunkObjects.push(enemy);
            }

            const wallTexture = new THREE.TextureLoader().load('wall.jpg');
            const numWalls = Math.floor(Math.random() * 3) + 1; 

            for (let i = 0; i < numWalls; i++) {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 10, 5), 
                    new THREE.MeshBasicMaterial({ map: wallTexture })
                );

                let wx, wz, isOverlapping;
                do {
                    wx = x + Math.random() * chunkSize;
                    wz = z + Math.random() * chunkSize;

                    isOverlapping = obstacles.some(ob => ob.position.distanceTo(new THREE.Vector3(wx, 5, wz)) < 7);
                } while (isOverlapping);

                wall.position.set(wx, 5, wz);
                scene.add(wall);
                obstacles.push(wall);
                chunkObjects.push(wall);
            }

            const obstacleTextures = [
                new THREE.TextureLoader().load('obstacle.jpg'),
                new THREE.TextureLoader().load('obstacle1.jpg'),
                new THREE.TextureLoader().load('obstacle2.jpg'),
                new THREE.TextureLoader().load('obstacle3.jpg')
            ];
            const numObstacles = Math.floor(Math.random() * 5) + 1; 

            for (let i = 0; i < numObstacles; i++) {
                const obstacle = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 3, 3), 
                    new THREE.MeshBasicMaterial({ map: obstacleTextures[Math.floor(Math.random() * obstacleTextures.length)] })
                );

                let ox, oz, isOverlapping;
                do {
                    ox = x + Math.random() * chunkSize;
                    oz = z + Math.random() * chunkSize;

                    isOverlapping = obstacles.some(ob => ob.position.distanceTo(new THREE.Vector3(ox, 1.5, oz)) < 5);
                } while (isOverlapping);

                obstacle.position.set(ox, 1.5, oz); 
                scene.add(obstacle);
                obstacles.push(obstacle);
                chunkObjects.push(obstacle);
            }

            loadedChunks.set(key, chunkObjects);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            document.body.addEventListener('click', () => document.body.requestPointerLock());

            const floorTexture = new THREE.TextureLoader().load('floor.jpg');
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(200, 200),
                new THREE.MeshBasicMaterial({ map: floorTexture })
            );
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            const wallTexture = new THREE.TextureLoader().load('wall.jpg');
            for (let i = 0; i < 50; i++) {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 10, 5),
                    new THREE.MeshBasicMaterial({ map: wallTexture })
                );

                let x, z;
                let isOverlapping;
                do {
                    x = Math.random() * 180 - 90; 
                    z = Math.random() * 180 - 90; 
                    isOverlapping = obstacles.some(w => w.position.distanceTo(new THREE.Vector3(x, 5, z)) < 7);
                } while (isOverlapping);

                wall.position.set(x, 5, z);
                scene.add(wall);
                obstacles.push(wall);
            }

            const textures = [
                new THREE.TextureLoader().load('obstacle.jpg'),
                new THREE.TextureLoader().load('obstacle1.jpg'),
                new THREE.TextureLoader().load('obstacle2.jpg'),
                new THREE.TextureLoader().load('obstacle3.jpg')
            ];

            const gridSize = 20; 
            const numRows = Math.floor(200 / gridSize);
            const numCols = Math.floor(200 / gridSize);
            const offsetX = -100 + gridSize / 2;
            const offsetZ = -100 + gridSize / 2;

            for (let i = 0; i < numRows; i++) {
                for (let j = 0; j < numCols; j++) {
                    const randomTexture = textures[Math.floor(Math.random() * textures.length)];

                    const box = new THREE.Mesh(
                        new THREE.BoxGeometry(5, 5, 5),
                        new THREE.MeshBasicMaterial({ map: randomTexture })
                    );

                    const x = i * gridSize + offsetX;
                    const z = j * gridSize + offsetZ;

                    box.position.set(x, 2.5, z); 
                    scene.add(box);
                    obstacles.push(box);
                }
            }

            console.log("Obstacles count:", obstacles.length);
            console.log("First obstacle position:", obstacles[0]?.position);

            camera.position.copy(spawnPoint);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', shoot);
            document.addEventListener('mousemove', lookAround);
            updateHealthBar();
            animate();

            const enemyTexture = new THREE.TextureLoader().load('enemy.jpg');

            for (let i = 0; i < 30; i++) {
                let enemy = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 2, 1),
                    new THREE.MeshBasicMaterial({ map: enemyTexture })
                );

                let x, z;
                let isOverlapping;
                do {
                    x = Math.random() * 180 - 90;
                    z = Math.random() * 180 - 90;
                    isOverlapping = enemies.some(e => e.position.distanceTo(new THREE.Vector3(x, 1, z)) < 5);
                } while (isOverlapping);

                enemy.position.set(x, 1, z);
                scene.add(enemy);
                enemies.push(enemy);
            }


        }

        function onKeyDown(event) {
            if (event.key === 'w') controls.forward = true;
            if (event.key === 's') controls.backward = true;
            if (event.key === 'd') controls.left = true;
            if (event.key === 'a') controls.right = true;
            if (event.key === ' ') controls.jump = true;
            if (event.key === 'Shift') controls.sneak = true;

            if (event.key === 'w' && event.ctrlKey && !sprintCooldown) {
                isSprinting = true;
                sprintTime = 0; 
            }
            if (!isMoving) {
                walkingSound.play();
                isMoving = true;
            }

            if (event.key === ' ') {
                controls.jump = true;
                if (!isJumping) {
                    jumpSound.currentTime = 0;
                    jumpSound.play();
                    isJumping = true;
                }
            }
        }

        function onKeyUp(event) {
            if (event.key === 'w') {
                controls.forward = false;
                isSprinting = false;
            }
            if (event.key === 's') controls.backward = false;
            if (event.key === 'd') controls.left = false;
            if (event.key === 'a') controls.right = false;
            if (event.key === ' ') controls.jump = false;
            if (event.key === 'Shift') controls.sneak = false; 

            if (!controls.w && !controls.s && !controls.a && !controls.d) {
                walkingSound.pause();
                walkingSound.currentTime = 0;
                isMoving = false;
            }
        }


        function lookAround(event) {
            if (document.pointerLockElement === document.body) {
                const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                euler.setFromQuaternion(camera.quaternion);

                euler.y -= event.movementX * lookSpeed; 
                euler.x -= event.movementY * lookSpeed;

                euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }
        }

        function shoot() {
            if (isReloading) return;

            if (ammo > 0 && bulletsInMag > 0) {
                const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                bullet.position.copy(camera.position);
                bullet.velocity = new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3())).multiplyScalar(playerBulletSpeed);
                bullets.push(bullet);
                scene.add(bullet);

                ammo--;
                bulletsInMag--;
                updateAmmoDisplay();
                updateMagazineDisplay();

                let gunshotSound = document.getElementById('gunshot-sound');
                gunshotSound.currentTime = 0;
                gunshotSound.play();

                if (bulletsInMag <= 0) {
                    startReload();
                }
            } else {
                playSound("cocking-sound");
            }
        }

        function startReload() {
            isReloading = true;
            console.log("Reloading... Please wait 5 seconds.");
            playSound("reload-sound"); 

            setTimeout(() => {
                isReloading = false;
                bulletsInMag = Math.min(magazineSize, ammo); 
                updateMagazineDisplay();
                console.log("Reload complete!");
            }, 5000);
        }

        function updateMagazineDisplay() {
            document.getElementById('magazine-display').innerText = `Mag: ${bulletsInMag} / ${magazineSize}`;
        }

        function spawnEnemy() {
            const enemyTexture = new THREE.TextureLoader().load('enemy.jpg');
            let newEnemy = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ map: enemyTexture }));
            newEnemy.position.set(Math.random() * 20 - 10, 1, Math.random() * 20 - 10);
            scene.add(newEnemy);
            enemies.push(newEnemy);
        }

        function enemyShoot() {
            const now = Date.now();

            enemies.forEach((enemy) => {
                if (!enemy.lastShot) {
                    enemy.lastShot = 0; 
                }

                if (now - enemy.lastShot > enemyCooldown) {
                    const enemyBullet = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                    );

                    enemyBullet.position.copy(enemy.position);

                    let directionToPlayer = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
                    enemyBullet.velocity = directionToPlayer.multiplyScalar(enemyBulletSpeed);

                    enemyBullets.push(enemyBullet);
                    scene.add(enemyBullet);

                    enemyBullet.alive = true;
                    setTimeout(() => { enemyBullet.alive = false; }, 3000);

                    enemy.lastShot = now; 
                }
            });
        }

        function checkCollisions(position) {
            for (const obj of [...obstacles, ...enemies]) {
                if (obj.position.distanceTo(position) < 2) {
                    return true;
                }
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);
            applyFlightMode();

            updatePlayerMovement();
            updateBullets();
            updateEnemyBullets();
            updateEnemies();

            enemyShoot();

            const playerChunkKey = getChunkKey(camera.position.x, camera.position.z);
            const [chunkX, chunkZ] = playerChunkKey.split(',').map(Number);

            for (let dx = -1; dx <= 1; dx++) {
                for (let dz = -1; dz <= 1; dz++) {
                    generateChunk((chunkX + dx) * chunkSize, (chunkZ + dz) * chunkSize);
                }
            }

            renderer.render(scene, camera);

            console.log(`Player Position: ${camera.position.x}, ${camera.position.y}, ${camera.position.z}`);
            enemies.forEach((enemy, index) => {
                console.log(`Enemy ${index} Position: ${enemy.position.x}, ${enemy.position.y}, ${enemy.position.z}`);
            });


            let moveSpeed = isSprinting ? sprintSpeed : walkSpeed;

            if (isSprinting) {
                sprintTime += 1 / 60; 
                if (sprintTime >= 10) { 
                    isSprinting = false;
                    sprintCooldown = true;
                    console.log("Sprint exhausted! Cooldown started.");
                    setTimeout(() => {
                        sprintCooldown = false;
                        console.log("Sprint ready again!");
                    }, 5000);
                }
            }

            let direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            if (controls.jump && isGrounded) {
                velocity.y = 0.2;
                isJumping = true; 
            }

            function updateEnemies() {
                enemies.forEach((enemy, index) => {
                    let playerDistance = enemy.position.distanceTo(camera.position);

                    if (playerDistance < detectionRange && playerDistance > stopRange) {
                        let directionToPlayer = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
                        let nextEnemyPosition = enemy.position.clone().add(directionToPlayer.multiplyScalar(enemySpeed));

                        const enemyChunkKey = getChunkKey(enemy.position.x, enemy.position.z);
                        const playerChunkKey = getChunkKey(camera.position.x, camera.position.z);

                        if (enemyChunkKey === playerChunkKey && !checkCollisions(nextEnemyPosition)) {
                            enemy.position.copy(nextEnemyPosition);
                        }
                    }
                });
            }

            function updatePlayerMovement() {
                let moveSpeed = isSprinting ? sprintSpeed : walkSpeed;

                if (isSprinting) {
                    sprintTime += 1 / 60;
                    if (sprintTime >= 10) {
                        isSprinting = false;
                        sprintCooldown = true;
                        setTimeout(() => sprintCooldown = false, 5000);
                    }
                }

                let direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                const nextPosition = camera.position.clone();
                if (controls.forward) nextPosition.add(direction.clone().multiplyScalar(moveSpeed));
                if (controls.backward) nextPosition.add(direction.clone().multiplyScalar(-moveSpeed));
                if (controls.left) nextPosition.add(new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), direction).multiplyScalar(-moveSpeed));
                if (controls.right) nextPosition.add(new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), direction).multiplyScalar(moveSpeed));

                if (!checkCollisions({ position: nextPosition }, obstacles)) {
                    camera.position.copy(nextPosition);
                }
            }

            function updateBullets() {
                bullets.forEach((bullet, index) => {
                    bullet.position.add(bullet.velocity);

                    let raycaster = new THREE.Raycaster(bullet.position, bullet.velocity.clone().normalize());
                    let intersects = raycaster.intersectObjects(obstacles, true);

                    if (intersects.length > 0 && intersects[0].distance < 1) {
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                    } else if (bullet.position.distanceTo(camera.position) > 150) {
                        scene.remove(bullet);
                        bullets.splice(index, 1);
                    }
                });
            }

            function updateEnemies() {
                enemies.forEach((enemy, index) => {
                    let playerDistance = enemy.position.distanceTo(camera.position);

                    if (playerDistance < detectionRange && playerDistance > stopRange) {
                        let directionToPlayer = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
                        let nextEnemyPosition = enemy.position.clone().add(directionToPlayer.multiplyScalar(enemySpeed));

                        if (!checkCollisions({ position: nextEnemyPosition }, obstacles)) {
                            enemy.position.copy(nextEnemyPosition);
                        }
                    }
                });
            }

            function updateEnemyBullets() {
                enemyBullets.forEach((bullet, index) => {
                    bullet.position.add(bullet.velocity);

                    let raycaster = new THREE.Raycaster(bullet.position, bullet.velocity.clone().normalize());
                    let intersects = raycaster.intersectObjects(obstacles, true);

                    if (intersects.length > 0 && intersects[0].distance < 1) {
                        scene.remove(bullet);
                        enemyBullets.splice(index, 1);
                    } else if (bullet.position.distanceTo(camera.position) < 1.5) {
                        if (!isAdmin) {
                            playerHealth -= 75;
                            updateHealthBar();
                            if (playerHealth <= 0) respawnPlayer();
                        }
                        scene.remove(bullet);
                        enemyBullets.splice(index, 1);
                    } else if (bullet.position.length() > 50) {
                        scene.remove(bullet);
                        enemyBullets.splice(index, 1);
                    }
                });
            }

            if (controls.jump && isGrounded) velocity.y = 0.2;
            velocity.y += gravity;
            camera.position.y += velocity.y;
            if (camera.position.y <= 2) { 
                camera.position.y = 2; 
                isGrounded = true; 
                velocity.y = 0; 
                isJumping = false;
            }
            else { 
                isGrounded = false;
            }

            bullets.forEach((bullet, index) => {
            bullet.position.add(bullet.velocity);

            enemies.forEach((enemy, enemyIndex) => {
                if (bullet.position.distanceTo(enemy.position) < 1) {
                    scene.remove(enemy);
                    enemies.splice(enemyIndex, 1);
                    scene.remove(bullet);
                    bullets.splice(index, 1);

                    let scoreEarned = 100;
                    ammo += 1;
                    score += scoreEarned;

                    addBattlePassProgress(scoreEarned);

                    updateScoreDisplay();

                    console.log(`Enemy killed! +${scoreEarned} Score`);
                    console.log(`Battle Pass Progress: ${bpProgress}/${bpRequiredPoints}`);

                    setTimeout(spawnEnemy, 5000);
                }
            });
            if (bullet.position.distanceTo(camera.position) > 150) {  
                scene.remove(bullet);
                bullets.splice(index, 1);
            }
        });



        enemyBullets.forEach((bullet, index) => {
            bullet.position.add(bullet.velocity);

            let raycaster = new THREE.Raycaster(bullet.position, bullet.velocity.clone().normalize());
            let intersects = raycaster.intersectObjects(obstacles, true);

            if (intersects.length > 0 && intersects[0].distance < 1) {
                scene.remove(bullet);
                enemyBullets.splice(index, 1);
            }
            else if (bullet.position.distanceTo(camera.position) < 1.5) { 
                if (!isAdmin) { 
                    playerHealth -= 75; 
                    updateHealthBar();

                    if (playerHealth <= 0) {
                        respawnPlayer();
                    }
                }
                scene.remove(bullet);
                enemyBullets.splice(index, 1);
            } 
            else if (bullet.position.length() > 50) {
                scene.remove(bullet);
                enemyBullets.splice(index, 1);
            }
        });

        function respawnPlayer() {
            playerHealth = 200; 
            camera.position.copy(spawnPoint); 
            velocity.set(0, 0, 0); 
            updateHealthBar();
            console.log("Player has respawned at spawn point.");
        }


        enemies.forEach((enemy, index) => {
            let playerDistance = enemy.position.distanceTo(camera.position);

            if (playerDistance < detectionRange && playerDistance > stopRange) {
                let directionToPlayer = new THREE.Vector3().subVectors(camera.position, enemy.position).normalize();
                let nextEnemyPosition = enemy.position.clone().add(directionToPlayer.multiplyScalar(enemySpeed));

                if (!checkCollisions({ position: nextEnemyPosition }, obstacles)) {
                    enemy.position.copy(nextEnemyPosition);
                }
            }
        });

            enemyShoot();

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();

        console.log("enemyAlive:", enemyAlive);
    </script>
</body>
</html>
